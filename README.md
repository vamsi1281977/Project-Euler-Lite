# Project-Euler-Lite
Answers to lite version of Project Euler problems.

This page contains answers to Project Euler problems for parameters easier than the ones at Project Euler, hence the lite. For answers to Project Euler problems, please visit: https://github.com/luckytoilet/projecteuler-solutions.

For problems we were able to solve ourselves or could find resources on the internet with hints and/or solutions (for example: https://euler.stephan-brumme.com/, mathblog site (not available anymore), etc.) we have provided the answer and a brief explanation as to how to solve the problem. For really hard problems with no internet resources to help, we will provide a lite answer.

NOTE: This page would not be possible without LuckyToilet's Project Euler Solutions page. I sincerely thank LuckyToilet and others who have contributed to the Project Euler Solutions page and other resources on the internet with hints and/or solutions to Project Euler problems, so that every one no matter what their mathematical or programming skills could enjoy Project Euler problems. 

1. Problem 001: S(n): sum of all multiples of 3 or 5 less than n. S(1000) = 233168. Can be solved using arithmetic progressions and the principle of inclusion-exclusion.
2. Problem 002: S(n): sum of even fibonacci numbers not greater than n. S(4000000) = 4613732. Can be solved by observing the pattern in 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... NOTE: E, O, O, E, O, O, E, ... where E means even and O means odd.
3. Problem 003: lgpf(n): largest prime factor of n. lgpf(600851475143) = 6857. NOTE: to compute the prime-factors of N, (naively) we only need to check 2 and all odd numbers in the interval [3, sqrt(N)].
4. Problem 004: The largest palindromic number that is a product of two three digit numbers is 906609.
5. Problem 005: lcm(1,2,3,...,20) = 232792560.
6. Problem 006: a(n): sum of the first n positive integers = (n * (n + 1)) / 2, b(n): sum of the squares of the first n positive integers = (n * (n + 1) * (n + n + 1)) / 6, (a(100) ** 2) - b(100) = 25164150.
7. Problem 007: This problem can be solved using a variation of Lucy Hedgehog's algorithm for Problem 10. Prime(10001) = 104743.
8. Problem 008: Largest product of 13 contiguous digits is 23514624000.
9. Problem 009: The Pythagorean triple with a + b + c = p = 1000 is (200, 375, 425) = 25 * (8, 15, 17). abc = 31875000.
10. Problem 010: Lucy Hedgehog has the best answer to this problem. The Lucy Hedgehog algorithm can be modified to compute Prime_Pi(x). The Prime_Pi(x) can be used to solve problem 7. S(x): sum of all primes not greater than x, S(2000000) = 142913828922.
11. Problem 011: We have to visit the following points: (x, y), (x + dx, y + dy), (x + dx + dx, y + dy + dy), (x + dx + dx + dx, y + dy + dy + dy) for (dx, dy) in (1, 0), (0, 1), (1, 1) and (1, (- 1)). We have to make sure the 4 points are in-bounds. The answer is: 70600674.
12. Problem 012: There are solutions based on the fact that GCD(2n, 2n + 1) = GCD(2n + 1, 2n + 2) = 1. NOTE: computing the number of divisors from the prime factorization of a number is well-known fact in elementary number theory. The answer is: 76576500.
13. Problem 013: There is no need for big-integer to solve this problem. Adding the first 15 digits of each number should be enough to get the answer: 5537376230.
14. Problem 014: Simple example demonstrating the usefulness of a technique called memoization. The problem can be solved without memoization, but memoization is going to come in handy for later problems. The answer is: 837799.
15. Problem 015: At any point in a (n + 1) x (n + 1) grid: f(a, b) = f(a - 1, b) + f(a, b - 1), with f(0, b) = 1 = f(a, 0) for 0 <= a,b <= n. The answer is: 137846528820.
16. Problem 016: Consider a programming environment with big-integer to solve this problem. The answer is: 1366.
17. Problem 017: A problem of a different flavor. A dictionary from int -> str, e.g. 1 -> 'one' etc. should help solve the problem. NOTE: there is a recursive structure to translating numbers to words. e.g. 982 = 900 + 82, to_words(982) = to_words(000) . ' and ' . to_words(82). Here '.' means string concatenation. The answer is: 21124.
18. Problem 018: Take all paths from the root node to any internal node. Do we have to consider each and every one of them to solve the problem or only the path with the maximum sum? The answer is: 1074.
19. Problem 019: Consider using an environment with calendar built in. The answer is: 171. This curiosly happens to be (12 * 100) // 7.
20. Problem 020: Consider using a programming environment with big-integer. The answer is: 648.
21. Problem 021: Computing the sum of proper divisors of a number from its prime factorization is a well known result in elementary number theory. The answer is: 31626.
22. A problem of a different flavor. A programming environment with builtin sort function is preferable. The answer is: 871198282.
23. Problem 023: Solving this problem is easy if you have already solved problem 21. The answer is: 4179871.
24. Problem 024: There are ways of solving this problem without enumerating the first million permutations. Simply enumerating the permutations using standard library is enough. Consider a programming environment with a permutations or next_permutation function available. The answer is: 2783915460.
25. Problem 025: This problem can be solved with big-integers very easily. With some help from WolframAlpha, use this problem as an opportunity to learn how to solve recurrence relations using generating functions. The answer is: 4782.
26. Problem 104: This problem seems to be intractable even for big-integers. Figure out how to compute the last 9 digits of fibonacci numbers, this is basic modular arithmetic. Then, figure out how to compute just the first 9 digits of fibonacci numbers, this is also basic modular arithmetic, but remember the solution to problem 013. There is no need to use big-integers to solve problem 013. The same technique applied here will give us the first 9 digits of fibonacci numbers. The answer is: 329468.
27. Problem 108: For this problem, we need to count solutions (x, y) to the equation,where x <= y. NOTE: n < x <= y. Let y = n + k and solve for x = ((n ^ 2) / k) + n. x <= y ==> n <= k. This means, the number of positive integer solutions to the equation for a given n is the number of divisors of (n ^ 2) greater than or equal to n. This is equal to (d(n ^ 2) + 1) / 2, where d(x) is the number of divisors of x. Counting the number of divisors of a number, given its prime factorization is a well known fact in elementary number theory. For this problem, simple brute-force is enough from here. The answer is: 180180.
28. Problem 110: As mentioned in the answer to problem 108, both problem 108 and problem 110 can be reduced to finding the smallest n such that d(n ^ 2) > (s + s - 1) where for problem 108, s = 1000 and for problem 110, s = 4000000. We can treat this as a minimization problem, where the objective function for problem 108 is: (2 ^ a) * (3 ^ b) * (5 ^ c) * (7 ^ d) * (11 ^ e) * (13 ^ f) * (17 ^ g). The constraints are (i) a >= b >= c >= d >= e >= f >= g; (ii) a < A, b < A, c < A, d < A, e < A, f < A, g < A, where A is a cutoff on the largest possible exponent. A = 4, was enough to solve both the problems; (iii) (a + a + 1) * (b + b + 1) * (c + c + 1) * (d + d + 1) * (e + e + 1) * (f + f + 1) * (g + g + 1) > (s + s - 1). Starting the minimization with (a,b,c,d,e,f,g) = (1,1,1,1,1,1,1,0) gives the answer in less than a second. We can setup a similar minimization problem for problem 110, starting with (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) = (1,1,1,1,1,1,1,1,1,1,1,1,0,0,0) gives the answer in less than a second. The answer is : 9350130049860600.
29. Problem 112: Simple brute-force is enough to solve this problem. The answer is: 1587000.
30. Problem 113: Non-bouncy numbers are either increasing numbers or decreasing numbers. Now, could a number be both increasing and decreasing at the same time? Yes, consider numbers of the form d, dd, ddd, ..., etc. If we had the count of n digit increasing numbers, could we somehow get the count of (n + 1) digit increasing numbers. To go from an n digit increasing number to (n + 1) digit increasing number, we need to know the last digit of the n digit increasing number. We should compute I(n, d): number of n digit increasing numbers ending in digit d, and D(n, d): number of n digit decreasing numbers ending in digit d; where d is in [0, 9]. Computing I(n + 1, d) from I(n, ?) should not be too hard. Similarly, computing D(n + 1, d) from D(n, ?) should not be too hard. The answer is: 51161058134250. 
31. Problem 119: The insight that allows us to solve this problem is: even in a range as large as [10, 10 ** 20) the digit sums have to lie in the range [1, 180]. We start with a digit sum d, and compute the geometric sequence: d, d ^ 2, d ^ 3, ..., (d ^ m) < (10 ** 20), (10 ** 20) < (d ^ (m + 1)). Check whether any of (d ^ i), 0 < i < (m + 1) have a digit sum equals to d. The answer is: 248155780267521.
32. Problem 120: Figure out why remainder(((a - 1)^n + (a + 1)^n), a^2) has only 4 terms. Then, simple brute-force should be enough. The answer is: 333082500.
33. Problem 122: This problem is more tricky than it looks, at a high level it is a simple depth-first-search, but the devil is in the book-keeping details. The main issue is: suppose there is a chain of exponents (a, b c, d, ..., e) of length n ending in e and another chain of exponents (a, b, f, g, ..., e) of the same length n ending in e. We would think picking one of those and extending should be enough to get the minimum chains for exponents greater than e, unfortunately this assumption turns out to be false. The reason being, say for example: the minimum chain to an exponent h > e, could use exponent f, instead of c or d. My code ran into such a problem for k == 77. The answer is: 1582.
34. Problem 125: Naive brute-force is enough to solve this problem. First, compute the set of palindromes less than the limit, this can be done much faster than checking each number for is_palindrome. Try to generate palindromes given a set of symbols like ('0', '1', '2', ..., '9'). Once we have the string version of the palindromes, filtering out the leading zeros is not too hard. There are 19998 palindromes less than the limit. Second, compute the set of all numbers less than the limit that can be expressed as sum of consecutive squares. There are 368979 of them less than the limit. Finally, compute the intersection of these two sets and sum the result. The answer is: 2906969179.
35. Problem 145: Figure out why 1-digit, 5-digit and 9-digit numbers cannot be reversible. Once this is done, simple brute-force is enough. The answer is: 608720.
36. Problem 187: Semi-intelligent brute-force is enough to solve this problem in under a minute of running time. We were able to do this in under 45 seconds using Python 3.9.16, PyPy 7.3.11 on a very performant laptop dated 2019. First compute all the primes less than ((100000000 // 2) + 287). 287 is the maximum prime-gap below 1000000000. Then, for every prime less than 10000, compute the number of primes in the interval [p, 100000000 // p]. Sum these up and we have the answer: 17427258.
37. Problem 206: We need to search for the answer in the interval L = math.isqrt(1020304050607080900) and U = math.isqrt(1929394959697989990). If the last digit of a square is 0, then the next to last digit of the square must also be a 0. This reduces the search space considerably, and is good enough to get the answer. Now, the last three digits of the square are '900', this means the number must end in '30' or '70'. This further reduces the search space. The answer is: 1389019170.
38. Problem 303: For this problem, f(9), f(99), f(999), f(2 * 999), f(3 * 999), ..., f(9 * 999) and f(9999) pose a difficulty. If it was not for these 'n', the problem could be solved with brute-force. Let us consider f(9), the sum of digits of any multiple of 9 is divisible by 9. If we only have digits 0, 1, 2 available, then 0 takes up a place and does not contribute to the sum, so we should not include 0 if we want the smallest multiple of 9 that has only digits 0, 1, 2. Now, for f(9) the candidates are 111111111, 11111112, 1111122, 111222, 12222. We can brute-force to verify f(9) is 12222. Now, let R(k) be the kth rep-unit, i.e. R(1) = 1, R(2) = 11, R(3) = 111, R(4) = 1111, etc. We have: 9 = 9 * R(1), 99 = 9 * R(2), 999 = 9 * R(3) and 9999 = 9 * R(4).
39. Problem 346: If a positive integer n is a repunit in base b, then it is also a repunit in base (n - 1), provided b < (n - 1). This gives us a very nice way to identify a strong repunit, given a repunit in base b. The answer is: 336108797689259276.
